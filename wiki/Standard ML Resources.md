# Standard ML Resources.

As should be obvious from the selection of the primary textbook, we
encourage students to use standard ML for building their compiler for
this course. As opposed to a language like C, a functional programming
language like ML allows expressing programs at a much higher level of
abstraction.  They are particularly well suited for building a
compiler. For example, algebraic data types give a direct way of
expressing the abstract syntax trees of languages. Syntax direct
translations between say two languages are then expressed naturally
using pattern matching on these abstract syntax trees. The strong
typing of ML helps detect errors early in the development and the
ability of the compiler to perform type inference reduce the clutter
in the definition of functions.

There is a bit of a learning curve to get started with a functional
programming language like ML and we cannot hope to have a full course
on functional programming. It is expected that the students will pick
up the necessary background for which we give some pointer. Here are
few pointers


1. [Notes on Programming Standard ML of New Jersey][ml-notes]
2. Reference for the Standard ML [Basis Library][basis-lib]
3. The [SML-family homepage](http://sml-family.org)


## ML-lex, ML-yacc and other parser generators.

In this class we will mostly be using `ml-lex` for lexical analysis and
`ml-yacc` for parser generators. The online tutorial for this is given below.

1. [ml-yacc][ml-yacc]
2. [ml-lex][ml-lex]


The input to `ml-yacc` is a `foo.grm` file (other possible extensions
are `.y` however we recommed the use of `.grm`). It produces the file
`foo.grm.sml` and `foo.grm.sig`. The program `ml-lex` takes its input
as a `foo.lex` file and generates a `foo.lex.sml` file.

## A tale of two compilers.

There are two options for you ML compilation needs. One is the
[SML system from New Jersey][smlnj] henceforth [smlnj] and the other
is [MLton][mlton]. The primary mode of usage of [smlnj] is as an
interpreter for Standard ML. Although there are ways by which a
standalone executable can be generated, I have found this to be really
painful. [MLton] *only* supports standalone compilation and the
generated executable are much more efficient in space and
time. However, mlton can take a while to compile large projects so if
you want to quickly check something it makes sense to use the [smlnj]
interpreter. This is the reason I recommend the use of both of
these. Here in a nutshell is the use case

[SML/NJ:][smlnj]
:   For interactive use.

[MLton:][mlton]
:   For standalone and production development.

There are subtle differences in the way these compilation systems work.
Without going into the details here is some of the important differences.

1. The parser and lexer generated by [ml-yacc][ml-yacc] and
   [ml-lex][ml-lex] is not compatible with [mlton]. Use the programs
   [`mlyacc`][mlyacc] and [`mllex`][mllex] instead (note the missing
   hyphen). These programs are identical in its input specification
   and hence the same documentation works for both.

2. For large projects like your semester long compiler project, you
   will need to split your files across multiple files. In such cases,
   it would be painful to compile/load files in the correct order. The
   [smlnj] uses a `.cm` file to describe the projects.  In the case of
   [mlton] a `.mlb` file is used. These are distinct specification and
   you might need to know both.

### SML/NJ compilation manager.

The [smlnj] interpreter uses a compilation manager which includes a
`.cm` file. You can load all the stuff in your project into the sml
interactive shell by typing.

```
sml project.cm
```

The `.cm` file is essentially a list of your `.sml`,`.grm` and `.lex`
with some control on what modules are exposed. The documentation is
available in [Chapter 6 of the notes above][ml-notes]. The above
command takes care of loading the file in the correct order and runs
the required processors like [`ml-lex`][ml-lex] and
[`ml-yacc`][ml-yacc].

### MLton and MLB files.

MLton uses a `.mlb` file for managing projects. These are simpler than
smlnj's `.cm` file in the sense that it contains just the `.sml` files
that constitute your project. You can compile the program with the following
command

```
mlton project.mlb
```

This will generate the standalone executable `project`. The MLB files
_do not_ run [`mllex`][mllex] or [`mlyacc`][mlyacc] and you will have
to run these by hand. I have found that it is easier to have a
Makefile as well which will run the tools. A sample makefile with the
following rules will ensure that all `.lex.sml` and `.grm.sml` files
are correctly generated.

```
%.lex.sml: %.lex
	mllex $<

%.grm.sml: %.grm
	mlyacc $<

```

The directory [`/reverse-polish`][reverse-polish]contains a complete
example of a compiler from expressions to reverse polish notation. It
contains source of two stand alone executables namely

`rp`:
:   A simple reverse polish calculator

`ec`:
:   A compiler that converts expressions to revers polish notation. The
    output of `ec` can be run by `rp`

It demonstrates the use lex and yacc with both `smlnj` and `mlton`.

### Cleaning up.

Since the output of [mllex] and [mlyacc] differ from that of [ml-lex]
and [ml-yacc], you need to ensure that a build with mlton is cleaned
up before building with smlnj.

[smlnj]: <http://www.smlnj.org/>
[mlton]: <http://www.mlton.org/>
[mlyacc]: <http://mlton.org/MLYacc>
[mllex]: <http://mlton.org/MLLex>
[ml-yacc]:<http://www.smlnj.org/doc/ML-Yacc/>
[ml-lex]: <http://www.smlnj.org/doc/ML-Lex/manual.html>
[modern]: <https://www.cs.princeton.edu/~appel/modern/ml/>
[appel]: <https://www.cs.princeton.edu/~appel>
[debian]: <https://www.debian.org>
[ml-notes]: <http://www.cs.cornell.edu/riccardo/prog-smlnj/notes-011001.pdf>
[basis-lib]: <http://sml-family.org/Basis/>
[reverse-polish]: <http://bitbucket.org/piyush-kurur/compilers/src/master/reverse-polish/>
