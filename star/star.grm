(* Interactive lang transpiler ? :-) *)

structure Ast = StarAst

%%

%eop EOF SEMI

(* %pos declares the type of positions for terminals.
   Each symbol has an associated left and right position. *)

%pos int

%left SUB PLUS
%left TIMES DIV
%right CARAT
%left AND
%left OR

%term ID of string | NUM of int | STRING of string
      | PLUS | TIMES | PRINT | COMMA
      | SEMI | EOF | CARAT | DIV | SUB
      | AND | OR | EQ | ASSIGN
      | GE | GT | LE | LT | NEQ
      | LBRACE | RBRACE | LPAREN | RPAREN
      | VAR | FUNCTION | BREAK | CONTINUE
      | WHILE | ELSE | IF | RETURN
      | END

%nonterm exp_ of Ast.Exp_
        | start of Ast.Start_ option
        | if_ of Ast.Stmt_
        | function_ of Ast.Function_
        | params_ of string list
        | body_ of Ast.Body_
        | bool_ of Ast.Bool_
        | comparison_ of Ast.RelOp_
        | assignment_ of Ast.Stmt_
        | while_ of Ast.Stmt_
        | print_ of Ast.Stmt_
        | program_ of Ast.Prog_
        | stm_ of Ast.Stmt_
        | functionCallParams_ of Ast.Exp_ list
        | functionCall_ of Ast.Exp_
        | logic_ of Ast.LoOp_

%name Star

%prefer PLUS TIMES DIV SUB LPAREN
%keyword WHILE BREAK CONTINUE RETURN FUNCTION VAR IF ELSE PRINT SEMI END

%noshift EOF
%verbose
%%

(* the parser returns the value associated with the exp_ression *)

  start : program_ (SOME (Ast.Prog(program_)))
   
  stm_ : assignment_ (Ast.Stmt(assignment_))
  	   | if_         (Ast.Stmt(if_))
  	   | while_      (Ast.Stmt(while_))
  	   | print_      (Ast.Stmt(print_))
       | BREAK       (Ast.Stmt(Ast.BREAK)) 
       | CONTINUE    (Ast.Stmt(Ast.CONTINUE)) 
       | RETURN      (Ast.Stmt(Ast.RETURN)) 

  program_ : END (Ast.END) 
    | function_ program_ (Ast.ProgPart(function_, program_))

  exp_ : NUM              (Ast.IntExp(NUM))
        | STRING            (Ast.StringExp(STRING))
        | ID               (Ast.IdExp(ID))
        | exp_ PLUS exp_    (Ast.OpExp(exp_1, Ast.Plus, exp_2))
        | exp_ TIMES exp_   (Ast.OpExp(exp_1, Ast.Times, exp_2))
        | exp_ DIV exp_     (Ast.OpExp(exp_1, Ast.Divide, exp_2))
        | exp_ SUB exp_     (Ast.OpExp(exp_1, Ast.Minus, exp_2))
        | exp_ CARAT exp_   (Ast.OpExp(exp_1, Ast.Carat, exp_2))

  body_ : stm_ body_        (Ast.StmtList(stm_, body_))
        | stm_              (Ast.StmtLast(stm_))
       
  assignment_ : VAR ID ASSIGN exp_  (Ast.AssStmt(ID, exp_))

  comparison_ : GE (Ast.GeOp) | GT (Ast.GtOp) | LE (Ast.LeOp) | LT (Ast.LtOp) | NEQ (Ast.NeqOp) | EQ (Ast.EqOp)

  logic_ : AND (Ast.AND) | OR (Ast.OR)

  bool_ : exp_                          (Ast.BoolExp1(exp_))
        | exp_ comparison_ exp_      (Ast.BoolExp2(exp_1, comparison_, exp_2))
        | bool_ logic_ bool_      (Ast.BoolExp3(bool_1, logic_, bool_2))

  while_ : WHILE LPAREN bool_ RPAREN LBRACE body_ RBRACE (Ast.WhileStmt(bool_, body_))

  print_ : PRINT LPAREN exp_ RPAREN (Ast.PrintStmt(exp_))

  params_ : ID ([ID]) | ID COMMA params_ (ID::params_)

  function_ : FUNCTION ID LPAREN params_ RPAREN LBRACE body_ RBRACE (Ast.Function(ID, params_, body_))

  functionCallParams_ : exp_ ([exp_]) | exp_ COMMA functionCallParams_ (exp_::functionCallParams_)

  functionCall_ : ID LPAREN functionCallParams_ RPAREN  (Ast.CallExp(ID, functionCallParams_))

  if_ : IF LPAREN bool_ RPAREN LBRACE body_ RBRACE  (Ast.IfStmt(bool_, body_))
      | IF LPAREN bool_ RPAREN LBRACE body_ RBRACE ELSE LBRACE body_ RBRACE (Ast.IfElseStmt(bool_, body_, body_))


